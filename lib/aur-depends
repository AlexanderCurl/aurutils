#!/usr/bin/env perl
use strict;
use warnings;
use v5.20;

my $argv0 = 'depends';
my $aur_json;

# Fallback to slower perl-based JSON parsing
if (eval { require JSON::XS; 1 }) {
    $aur_json = JSON::XS->new;
} else {
    require JSON::PP;
    $aur_json = JSON::PP->new;
}

sub parse_json {
    my $row = shift;

    my $obj = $aur_json->incr_parse($row)
        or die $argv0 . ": expected JSON object or array at beginning of string";
    $aur_json->incr_reset();

    return $obj;
}

# Remove outer layer of AurJson responses
sub get_results {
    my $obj = shift;

    if ($obj->{'type'} eq 'error') {
        say STDERR "$argv0: $obj->{'error'}";
        exit(4);
    }
    return $obj->{'results'};
}

# Retrieve AurJson responses in every level of the dependency DAG
sub query {
    return if scalar @_ == 0;
    my @results;

    my @command = ('aur', 'query', '--type', 'info', @_);
    my $child_pid = open(my $fh, "-|", @command) or die $!;

    if ($child_pid) { # parent process
        while (my $row = <$fh>) {
            chomp $row;

            # single JSON structure per request (max. 5000 packages per request)
            push(@results, @{get_results(parse_json($row))});
        }
        die if $!;

        waitpid($child_pid, 0);
    }
    exit(2) if $?;

    return @results;
}

sub chain {
    my ($targets, $types, $max_req, $handler) = @_;
    my @depends = @{$targets};
    my (%results, %reqby, %shlibs);

    # Add `Self` type for explicit targets
    map { $reqby{$_}{'Self'} = [$_] } @{$targets};
    map { $shlibs{$_} = [$_, 0] } @{$targets};

    for my $a (1..$max_req) {
        say STDERR join(" ", "query: [$a]", @depends) if defined $ENV{'AUR_DEBUG'};

        if ($a == $max_req) {
            say STDERR "$argv0: total requests: $a (out of range)";
            exit(34);
        }
        my @level = $handler->(@depends);

        if (not scalar(@level)) {
            last;  # no results
        }
        @depends = ();

        for my $node (@level) {
            $results{$node->{'Name'}} = $node;

            # XXX: no check if provides has valid package version (vercmp)
            for my $spec (@{$node->{'Provides'} // []}) {
                my ($prov, $op, $ver) = split(/(<=|>=|<|=|>)/, $spec);

                # XXX: only keeps the first provider
                if (not defined $shlibs{$prov}) {
                    # Use weights to make explicit provides take precedence
                    $shlibs{$prov} = [$node->{'Name'}, $a]
                }
            }

            # Filter out dependency types early (#882)
            for my $deptype (@{$types}) {
                if (not defined($node->{$deptype})) {
                    next;  # no dependency of this type
                }

                for my $spec (@{$node->{$deptype}}) {
                    # valid operators (important: <= before <)
                    my ($dep, $op, $ver) = split(/(<=|>=|<|=|>)/, $spec);

                    # populate reverse depends
                    push(@{$reqby{$dep}{$deptype}}, $node->{'Name'});

                    # avoid querying duplicate packages (#4)
                    if (defined $results{$dep}) {
                        next;
                    }
                    push(@depends, $dep);

                    # mark as incomplete (retrieved in next step or repo package)
                    $results{$dep} = 'None';
                }
            }
        }
    }
    return \%results, \%reqby, \%shlibs;
}

sub chain_mod {
    my ($results, $reqby, $shlibs, $provides, $show_all) = @_;
    %{$shlibs} = () if not $provides;
    my %mod;

    # Add reverse dependencies for AUR targets
    say STDERR "query: filtering results" if defined $ENV{'AUR_DEBUG'};
    map {
        # Take provides on the command-line into account (#837)
        if (defined $shlibs->{$_} and $shlibs->{$_}->[1] == 1) {
            my $name = $shlibs->{$_}->[0];

            # Preserve `Self` deptype of command-line target
            $mod{$name} = $results->{$name};
            $mod{$name}->{'RequiredBy'} = {%{$reqby->{$_}}, %{$reqby->{$name}}};
        }
        # Avoid overriding provides with later target (random ordering of hash!)
        elsif (not defined $mod{$_}) {
            $mod{$_} = $results->{$_};
            $mod{$_}->{'RequiredBy'} = $reqby->{$_};
        }
    } grep {
        $results->{$_} ne 'None'
    } keys %{$results};

    # Merge reverse dependencies for purely virtual targets, with
    # corresponding packages specified on the command-line
    map {
        my $name = $shlibs->{$_}[0];

        for my $deptype (keys %{$reqby->{$_}}) {
            push(@{$mod{$name}->{'RequiredBy'}{$deptype}}, @{$reqby->{$_}{$deptype}});
        }
    } grep {
        $results->{$_} eq 'None' and defined $shlibs->{$_}
    } keys %{$results};

    return \%mod if not $show_all;

    # Add reverse dependencies for any remaining targets
    map {
        $mod{$_}->{'Name'} = $_;
        $mod{$_}->{'RequiredBy'} = $reqby->{$_};
    } grep {
        $results->{$_} eq 'None'
    } keys %{$results};

    return \%mod;
}

# tsv output for usage with aur-sync (aurutils <=10)
sub table_v10_compat {
    my ($results, $types) = @_;

    map {
        my ($name, $base, $version) = ($_->{'Name'}, $_->{'PackageBase'}, $_->{'Version'});
        say join("\t", $name, $name, $base, $version, 'Self');

        for my $deptype (@{$types}) {
            my $depends = $_->{$deptype};
            next if (ref($depends) ne 'ARRAY');

            for my $dep (@{$depends}) {
                say join("\t", $name, $dep, $base, $version, $deptype);
            }
        }
    } grep { defined $_->{'PackageBase'} } values %{$results};
}

# tsv output for usage with aur-sync (aurutils >=11)
sub table {
    my $results = shift;

    for my $pkg (values %{$results}) {
        my ($name, $base, $version) = ($pkg->{'Name'}, $pkg->{'PackageBase'}, $pkg->{'Version'});

        for my $deptype (keys %{$pkg->{'RequiredBy'}}) {
            map { 
               say join("\t", $name, $_, $base // '-', $version // '-', $deptype);
            } @{$pkg->{'RequiredBy'}{$deptype}};
        }
    }
}

# package/dependency pairs for use with tsort(1) or aur-graph
# XXX: include optional column for versioned dependencies
sub pairs {
    my ($results, $key, $reverse) = @_;

    for my $pkg (values %{$results}) {
        my $target = $pkg->{$key};

        for my $reqby (values %{$pkg->{'RequiredBy'}}) {
            map {
                my $rdep = $key eq 'Name' ? $_ : $results->{$_}->{$key} // '-';
                my @pair = $reverse ? ($target, $rdep) : ($rdep, $target);

                say join("\t", @pair);
            } @{$reqby};
        }
    }
}

unless(caller) {
    use Getopt::Long;
    my $opt_depends      = 1;
    my $opt_makedepends  = 1;
    my $opt_checkdepends = 1;
    my $opt_optdepends   = 0;
    my $opt_mode         = "pairs";
    my $opt_pkgname      = 0;
    my $opt_show_all     = 0;  # implies $opt_pkgname = 1
    my $opt_reverse      = 0;
    my $opt_provides     = 1;

    GetOptions(
        'no-depends'      => sub { $opt_depends = 0 },
        'no-makedepends'  => sub { $opt_makedepends = 0 },
        'no-checkdepends' => sub { $opt_checkdepends = 0 },
        'optdepends'      => \$opt_optdepends,
        'no-provides'     => sub { $opt_provides = 0 },
        'n|pkgname'       => \$opt_pkgname,
        'b|pkgbase'       => sub { $opt_pkgname = 0 },
        'G|graph'         => sub { },  # noop
        't|table'         => sub { $opt_mode = "table" },
        'J|json'          => sub { $opt_mode = "json" },
        'r|reverse'       => \$opt_reverse,
        'a|all'           => \$opt_show_all
    ) or exit(1);

    my @types;
    push(@types, 'Depends')      if $opt_depends;
    push(@types, 'MakeDepends')  if $opt_makedepends;
    push(@types, 'CheckDepends') if $opt_checkdepends;
    push(@types, 'OptDepends')   if $opt_optdepends;

    # Resolve dependency tree
    my $results = chain_mod(chain(\@ARGV, \@types, 30, \&query), $opt_provides, $opt_show_all);

    if ($opt_mode eq 'pairs') {
        pairs($results, ($opt_pkgname or $opt_show_all) ? 'Name' : 'PackageBase', $opt_reverse);
    }
    elsif ($opt_mode eq 'table' and $opt_reverse) {
        table($results);
    }
    elsif ($opt_mode eq 'table') {
        table_v10_compat($results, \@types);
    }
    elsif ($opt_mode eq 'json') {
        $aur_json->canonical();
        say $aur_json->encode($results);
    }
    else {
        say STDERR "$argv0: invalid mode selected";
        exit(1);
    }
}
