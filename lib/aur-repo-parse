#!/usr/bin/env perl
use strict;
use warnings;
use v5.20;

use open ":std", ":encoding(UTF-8)";
use Cwd 'abs_path';
use File::Basename;

use AUR::Json qw(write_json);
use AUR::Repo qw(check_attr list_attr parse_db);
my $argv0 = 'repo-parse';

sub repo_json {
    my ($pkg, $count, $last, $db_path, $db_name) = @_;

    if (defined $pkg) {
        # Additional fields for `aur-format`
        $pkg->{'DBPath'}     = $db_path;
        $pkg->{'Repository'} = $db_name;

        print '[' if $count == 1;
        print ',' if $count  > 1;

        my $json_text = write_json($pkg);
        print $json_text;
    }
    print "]\n" if $last == 1;
}

sub repo_jsonl {
    my ($pkg, undef, undef, $db_path, $db_name) = @_;
    return if not defined $pkg;

    # Additional fields for `aur-format`
    $pkg->{'DBPath'}     = $db_path;
    $pkg->{'Repository'} = $db_name;

    my $json_text = write_json($pkg);
    print $json_text . "\n";
}

sub repo_list {
    my ($pkg, undef, undef, $delim, $quiet) = @_;
    return if not defined $pkg;

    my $name = $pkg->{'Name'};
    my $pver = $pkg->{'Version'};

    if ($quiet) {
        say $name;
    } else {
        say join($delim, $name, $pver);
    }
}

sub repo_table {
    my ($pkg, undef, undef, $delim) = @_;
    return if not defined $pkg;

    my $name = $pkg->{'Name'};
    my $base = $pkg->{'PackageBase'};
    my $pver = $pkg->{'Version'};

    say join($delim, $name, $name, $base, $pver, 'Self');

    for my $key ('Depends', 'MakeDepends', 'CheckDepends') {
        if (ref($pkg->{$key}) eq 'ARRAY') {
            map { say join($delim, $name, $_, $base, $pver, $key) } @{$pkg->{$key}};
        }
    }
}

sub repo_attr {
    my ($pkg, undef, undef, $label) = @_;
    return if not defined $pkg;

    my $value = $pkg->{$label};

    if (defined($value) and ref($value) eq 'ARRAY') {
        say join("\n", @{$value});
    } elsif (defined($value)) {
        say $value;
    }
}

unless (caller) {
    use Getopt::Long;
    my $opt_json = 0;
    my $opt_jsonl = 0;
    my $opt_list = 0;
    my $opt_list_attr = 0;
    my $opt_table = 0;
    my $opt_quiet = 0;
    my $opt_delim;
    my $opt_attr = "";
    my @opt_db_path;
    my $opt_stdin = 0;
    my $opt_search = "";
    my $opt_search_by = 'Name';

    GetOptions('J|json'          => \$opt_json,
               'jsonl'           => \$opt_jsonl,
               'F|field|attr=s'  => \$opt_attr,
               'l|list'          => \$opt_list,
               'q|quiet'         => \$opt_quiet,
               't|table'         => \$opt_table,
               'd|delim'         => \$opt_delim,
               'list-attr'       => \$opt_list_attr,
               'p|path=s'        => \@opt_db_path,
               's|search=s'      => \$opt_search,
               'search-by=s'     => \$opt_search_by)
        or exit(1);

    if (scalar(@ARGV) > 0 and ($ARGV[0] eq "-" or $ARGV[0] eq "/dev/stdin")) {
        $opt_stdin = 1;
    }
    elsif ($opt_list_attr) {
        say join("\n", list_attr());
        exit(0);
    }
    elsif (scalar(@opt_db_path) < 1 and not $opt_stdin) {
        say STDERR $argv0 . ': repository path must be specified';
        exit(1);
    }

    # Callback function run on each entry in the database
    my ($handler, @varargs);

    if ($opt_json) {
        $handler = \&repo_json;
        # @varargs defined in input loop
    }
    elsif ($opt_jsonl) {
        $handler = \&repo_jsonl;
        # @varargs defined in input loop
    }
    elsif (length($opt_attr)) {
        my $attr_label = check_attr($opt_attr);

        if (not defined $attr_label) {
            say STDERR "$argv0: unknown attribute '$opt_attr'";
            exit(2);
        }
        $handler = \&repo_attr;
        @varargs = ($attr_label);
    }
    elsif ($opt_list) {
        $handler = \&repo_list;
        @varargs = (length($opt_delim) ? $opt_delim : "\t", $opt_quiet);
    }
    elsif ($opt_table) {
        $handler = \&repo_table;
        @varargs = (length($opt_delim) ? $opt_delim : "\t");
    }
    else {
        say STDERR $argv0 . ': no mode specified';
        exit(1);
    }
 
    # Verify search field
    my $search_label = check_attr(uc($opt_search_by));

    if (not defined $search_label) {
        say STDERR "$argv0: unknown attribute '$opt_search_by'";
        exit(2);
    }
    my @parse_args = ($handler, $opt_search, $search_label);

    # Take input from stdin instead of a pacman database
    if ($opt_stdin) {
        if ($opt_json or $opt_jsonl) {
            @varargs = ("/dev/stdin", "local");
        }
        parse_db(*STDIN, "/dev/stdin", 'local', 'FILENAME', @parse_args, @varargs);
        exit(0);
    }

    # bsdtar(1) does not support extracting multiple files in a single invocation,
    # so fork a new process for each specified path.
    for my $db_path (@opt_db_path) {
        my $db_abs_path = abs_path($db_path);
        my $db_name = basename($db_path);

        if (not length($db_abs_path)) {
            say STDERR $argv0 . ": file path '$db_path' not found";
            exit(2);
        }

        # repo-add(8) only accepts *.db or *.db.tar* extensions
        if ($db_name =~ /\.(db|files)(\.tar(\.\w+)?)?$/g) {
            $db_name = substr $db_name, 0, $-[0];
        } else {
            say STDERR "$argv0: $db_name does not have a valid database archive extension";
            exit(1);
        }

        # When parsing the database, do not require a full extraction to either memory or disk
        # by reading `tar` output line-by-line. It is not strictly necessary to depend on
        # attribute order (i.e. %FILENAME% occuring in first place) while doing so; however,
        # the `--verbose` flag printing file names has different behavior for different `tar`
        # versions. Specifically, `bsdtar -xv` does not add a newline after the file path,
        # while `tar -xv` does.
        my @extract = ('bsdtar', '-Oxf', $db_abs_path);
        my $child_pid = open(my $fh, "-|", @extract) or die $!;

        if ($child_pid) { # parent process
            if ($opt_json or $opt_jsonl) {
                @varargs = ($db_abs_path, $db_name);
            }
            my $count = parse_db($fh, 'FILENAME', @parse_args, @varargs);

            waitpid($child_pid, 0);
        }
        exit(2) if $?;
    }
}

# vim: set et sw=4 sts=4 ft=perl:
