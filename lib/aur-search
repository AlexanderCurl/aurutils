#!/usr/bin/env perl
use strict;
use warnings;
use v5.20;

use POSIX qw(strftime setlocale LC_NUMERIC LC_TIME LC_ALL);
use locale qw(:numeric :time);

use Term::ANSIColor qw(:constants);
use constant OSC8 => "\033]8";
use constant ST   => "\033\\";

my $argv0 = 'search';
my $aur_json;
my $aur_location = $ENV{AUR_LOCATION} // 'https://aur.archlinux.org';

# sprintf, strftime()
setlocale(LC_NUMERIC, 'C');
setlocale(LC_TIME,    'C');

# Fallback to slower perl-based JSON parsing
if (eval { require JSON::XS; 1 }) {
    $aur_json = JSON::XS->new;
} else {
    require JSON::PP;
    $aur_json = JSON::PP->new;
}

sub parse_json {
    my $row = shift;

    my $obj = $aur_json->incr_parse($row)
        or die $argv0 . ": expected JSON object or array at beginning of string";
    $aur_json->incr_reset();

    return $obj;
}

sub get_results {
    my $obj = shift;

    if (ref($obj) eq 'ARRAY') {
        return $obj;
    }
    elsif ($obj->{'type'} eq 'error') {
        say STDERR "$argv0: $obj->{'error'}";
        exit(4);
    }
    return $obj->{'results'};
}

sub format_long {
    my $pkg = shift;
    my $url = join("/", $aur_location, $pkg->{'Name'});
    say BOLD, sprintf("%-15s", "AUR URL:"), RESET, ' ', $url;

    # Custom fixed order for info output
    my @keys = (
        'Name'       , 'PackageBase' , 'Version'        , 'Description' , 'URL',
        'Keywords'   , 'License'     , 'Maintainer'     , 'Submitter'   , 'NumVotes',
        'Popularity' , 'OutOfDate'   , 'FirstSubmitted' , 'LastModified', 'Depends',
        'MakeDepends', 'CheckDepends', 'OptDepends'
    );
    for my $k (@keys) {
        # XXX: duplicates info_expand_field() from aur-format
        my $f;
        if (ref $pkg->{$k} eq 'ARRAY') {
            $f = join(' ', @{$pkg->{$k} // ['-']});
        } elsif ($k eq 'LastModified' or $k eq 'OutOfDate' or $k eq 'FirstSubmitted') {
            $f = defined $pkg->{$k} ? gmtime $pkg->{$k} : '-';
        } else {
            $f = $pkg->{$k} // '-';
        }
        say BOLD, sprintf("%-15s", "$k:"), RESET, ' ', $f;
    }
} 

sub format_short {
    my $pkg   = shift;
    my $name  = $pkg->{'Name'};
    my $desc  = $pkg->{'Description'};
    my $ver   = $pkg->{'Version'};
    my $votes = $pkg->{'NumVotes'};

    # Formatted fields
    my $ood  = defined $pkg->{'OutOfDate' } 
        ? strftime("(Out-of-date: %d %B %Y)", gmtime $pkg->{'OutOfDate'}) : "";
    my $orph = defined $pkg->{'Maintainer'} 
        ? "" : "(Orphaned) ";
    my $pop  = sprintf("%.2f", $pkg->{'Popularity'});
    my $pre  = sprintf("%s%saur/%s%s%s", BOLD, BLUE, RESET, BOLD, $name);

    # OSC sequences
    if (not exists $ENV{ANSI_COLORS_DISABLED}) {
        $pre = sprintf("%s;;%s%s%s%s;;%s", OSC8, "$aur_location/packages/$name", ST, $pre, OSC8, ST);
    }

    say $pre, ' ', GREEN, $ver, RESET, ' (+', $votes, ' ', $pop, '%) ', 
        $orph, BOLD, RED, $ood, RESET;
    say '    ', $desc // '-';
}

# Set union by hash value
sub results_union {
    my ($target, $results, $seen, $union_key) = @_;

    if (!keys %{$seen}) {
        %{$seen} = map { $_->{$union_key} => 1 } @{$results};
    }
    push(@{$results}, grep { !$seen->{$_->{$union_key}}++ } @{$target});
 }

# Set intersection by hash value
sub results_isect {
    my ($target, $results, $isect_key) = @_;
    my %seen = map { $_->{$isect_key} => 1 } @{$target};

    @{$results} = grep { $seen{$_->{$isect_key}} } @{$results};
 }

# Sort a flattened array of hashes
sub results_rsort {
    my ($results, $sort_key, $reverse) = @_;

    # Sort entries by value of specified key
    if ($sort_key eq 'Popularity' or $sort_key eq 'NumVotes') {
        @{$results} = sort { $a->{$sort_key} <=> $b->{$sort_key} } @{$results};
    } elsif (length $sort_key) {
        @{$results} = sort { $a->{$sort_key} cmp $b->{$sort_key} } @{$results};
    }
    if ($reverse) {
        @{$results} = reverse @{$results};
    }
}

unless(caller) {
    # option handling
    use Getopt::Long;
    my $opt_multiple  = 'section';
    my $opt_type      = 'search';
    my $opt_search_by = 'name-desc';
    my $opt_sort_key  = '';
    my $opt_color     = 'auto';
    my $opt_reverse   = 0;
    my $opt_format    = '';
    my $opt_stdin     = 0;

    # XXX: add option to disable set operations, --time-format
    GetOptions (
        'a|any'        => sub { $opt_multiple  = 'union' },
        'i|info'       => sub { $opt_type      = 'info' },
        's|search'     => sub { $opt_type      = 'search' },
        'd|desc'       => sub { $opt_search_by = 'name-desc' },
        'm|maintainer' => sub { $opt_search_by = 'maintainer' },
        'n|name'       => sub { $opt_search_by = 'name' },
        'depends'      => sub { $opt_search_by = 'depends' },
        'makedepends'  => sub { $opt_search_by = 'makedepends' },
        'optdepends'   => sub { $opt_search_by = 'optdepends' },
        'checkdepends' => sub { $opt_search_by = 'checkdepends' },
        'q|short'      => sub { $opt_format    = 'short' },
        'v|verbose'    => sub { $opt_format    = 'long' },
        'J|json'       => sub { $opt_format    = 'json' },
        'color=s'      => \$opt_color,
        'r|reverse'    => \$opt_reverse,
        'k|key=s'      => \$opt_sort_key,
        'json-stdin'   => \$opt_stdin  # disambiguate `-`, `/dev/stdin`
    ) or exit(1);

    # Colored messages on both stdout and stderr may be desired if stdout is not
    # connected to a terminal, e.g. when piping to less -R. (#585) When printing
    # to a file, they should be disabled instead. Default to `--color=auto` but
    # allow specifying other modes.
    my $colorize = 0;
    if (not defined $ENV{AUR_DEBUG}) {
        if (($opt_color eq 'auto' and -t STDOUT) or $opt_color eq 'always') {
            $colorize = 1;
        }
    }
    if ($colorize == 0) {
        $ENV{ANSI_COLORS_DISABLED} = 1;
    }

    # Set format depending on query type (#319)
    if (not length($opt_format)) {
        $opt_format = $opt_type eq 'info' ? 'long' : 'short';
    }

    # Retrieve JSON responses
    my @command = $opt_stdin ? ('cat') : ('aur', 'query', '-t', $opt_type, @ARGV);
    my @results;
    my $child_pid = open(my $fh, "-|", @command) or die $!;

    # Build list of results starting at the first response.
    if ($child_pid) {
        my $first = <$fh>;
        chomp $first if defined $first;

        if (length($first)) {
            @results = @{get_results(parse_json($first))};
        }
        my %seen;

        while (my $row = <$fh>) {
            chomp $row;
            my @next = @{get_results(parse_json($row))};

            if ($opt_multiple eq 'union') {
                results_union(\@next, \@results, \%seen, 'Name');
            }
            elsif ($opt_multiple eq 'section') {
                results_isect(\@next, \@results, 'Name');
            }
            else {
                push(@results, @next);
            }
        }
        die if $!;

        waitpid($child_pid, 0);
    }
    exit(2) if $?;
    exit(1) if scalar @results == 0;

    # Apply sorting criteria
    if (length $opt_sort_key or $opt_reverse) {
        results_rsort(\@results, $opt_sort_key, $opt_reverse);
    }

    # Format results to standard output
    if ($opt_format eq 'short') {
        map { format_short($_) } @results;
    }
    elsif ($opt_format eq 'long') {
        my $i = 0;
        map { format_long($_); say '' if ++$i < scalar @results } @results;
    }
    elsif ($opt_format eq 'json') {
        $aur_json->canonical();
        say $aur_json->encode(\@results);
    }
    else {
        die 'invalid format';
    }
}

# vim: set et sw=4 sts=4 ft=awk:
