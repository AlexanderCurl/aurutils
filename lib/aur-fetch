#!/bin/bash
# aur-fetch - retrieve build files from the AUR
[[ -v AUR_DEBUG ]] && set -o xtrace
shopt -s extglob
argv0=fetch
AUR_LOCATION=${AUR_LOCATION:-https://aur.archlinux.org}
XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[1]}(): }'

# author information for merge commits
export GIT_AUTHOR_NAME=aurutils
export GIT_AUTHOR_EMAIL=aurutils@localhost
export GIT_COMMITTER_NAME=aurutils
export GIT_COMMITTER_EMAIL=aurutils@localhost

# default options
existing=0 recurse=0 sync=pull

results() {
    local mode=$1 prev=$2 current=$3 path=$4 dest=$5

    if [[ -w $dest ]]; then
        printf >> "$dest" '%s:%s:%s:file://%s\n' "$mode" "$prev" "$current" "$path"
    fi
}

usage() {
    cat <<! | base64 -d
ICAgICAgICAgICAgIC4tLX5+LF9fCjotLi4uLiwtLS0tLS0tYH5+Jy5fLicKIGAtLCwsICAs
XyAgICAgIDsnflUnCiAgXywtJyAsJ2AtX187ICctLS4KIChfLyd+fiAgICAgICcnJycoOwoK
!
    plain >&2 'usage: %s [-S] [--] pkgname...' "$argv0"
    exit 1
}

source /usr/share/makepkg/util/message.sh
source /usr/share/makepkg/util/parseopts.sh

if [[ ! -v NO_COLOR ]] && [[ ! -v AUR_DEBUG ]]; then
    [[ -t 2 ]] && colorize
fi

opt_short='rS'
opt_long=('no-pull' 'rebase' 'reset' 'no-rebase' 'results:' 'existing' 'recurse'
          'no-commit' 'autostash' 'ff-only' 'sync:')
opt_hidden=('dump-options')

if ! parseopts "$opt_short" "${opt_long[@]}" "${opt_hidden[@]}" -- "$@"; then
    usage
fi
set -- "${OPTRET[@]}"

unset pull_args results_file
while true; do
    case "$1" in
        ## fetch options
        --existing)
            existing=1 ;;
        --no-pull)
            sync=fetch ;;
        --reset)
            sync=reset ;;
        --results)
            shift; results_file=$(realpath -- "$1") ;;
        --sync)
            shift; sync=$1 ;;
        ## git-pull options
        --autostash)
            pull_args+=(--autostash) ;;
        --ff-only)
            pull_args+=(--ff-only) ;;
        --rebase)
            pull_args+=(--rebase) ;; # git-rebase
        --no-rebase)
            pull_args+=(--no-rebase) ;; # git-merge
        --no-commit)
            # --no-ff so that a fast-forward merge also adds no new commits
            pull_args+=(--no-commit --no-ff) ;;
        ## deprecated options
        -S)
            ;; # no-op, default git-pull behavior
        --recurse|-r)
            recurse=1 ;;
        --dump-options)
            printf -- '--%s\n' "${opt_long[@]}" ${AUR_DEBUG+"${opt_hidden[@]}"}
            printf -- '%s' "${opt_short}" | sed 's/.:\?/-&\n/g'
            exit ;;
        --) shift; break ;;
    esac
    shift
done

case $sync in
    !(pull|fetch|reset))
        error '%s: invalid --sync option: %s' "$argv0" "$sync"
        usage ;;
esac

if (( ! $# )); then
    error '%s: no arguments given' "$argv0"
    exit 1
fi

if [[ -v results_file ]]; then
    : >"$results_file" || exit 1 # truncate file
fi

if (( recurse )); then
    aur depends --pkgbase "$@" # stdin handled by aur-depends

elif (( $# == 1 )) && [[ $1 == "-" || $1 == "/dev/stdin" ]]; then
    tee # noop
else
    printf '%s\n' "$@"
fi | while read -r pkg; do
    unset -f git

    if (( existing )) && ! git ls-remote --exit-code "$AUR_LOCATION/$pkg" >/dev/null; then
        warning '%s: package is not in AUR, skipping' "$argv0" "$pkg"
        continue

    elif [[ -d $pkg/.git ]]; then
        # Avoid issues with filesystem boundaries (#274)
        git() { command git -C "$pkg" "$@"; }

        # HEAD is assumed to point to a valid commit
        prev_head=$(git rev-parse --verify --quiet HEAD)

        if [[ ! $prev_head ]]; then
            warning '%s: %s: HEAD not found, skipping repository' "$argv0" "$pkg"
            continue
        fi

        # Merge in new history
        ref=0
        case $sync in
            pull)
                ref='HEAD'
                git pull origin master "${pull_args[@]}" -v ;;
            fetch)
                ref='FETCH_HEAD'
                git fetch origin -v ;;
            reset)
                ref='master@{upstream}'
                git fetch origin -v && git reset --hard "$ref" ;;
        esac >&2 || {
            error '%s: %s: --sync=%s failed' "$argv0" "$pkg" "$sync"
            exit 1
        }

        if [[ -v results_file ]]; then
            commit=$(git rev-parse --verify "$ref")
            results "$sync" "$prev_head" "$commit" "$PWD/$pkg" "$results_file"
        fi

    # Otherwise, try to clone anew
    elif git clone "$AUR_LOCATION/$pkg" >&2; then
        # Verify if the repository is empty (#959)
        if head=$(git -C "$pkg" rev-parse --verify --quiet HEAD); then
            git -C "$pkg" --no-pager log --pretty=reference -1 >&2
        fi

        if [[ -v results_file ]]; then
            results 'clone' '0' "${head:-0}" "$PWD/$pkg" "$results_file"
        fi
    else
        error '%s: %s: failed to clone repository' "$argv0" "$pkg"
        exit 1
    fi
done

# vim: set et sw=4 sts=4 ft=sh:
