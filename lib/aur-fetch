#!/bin/bash
# aur-fetch - retrieve build files from the AUR
[[ -v AUR_DEBUG ]] && set -o xtrace
argv0=fetch
AUR_LOCATION=${AUR_LOCATION:-https://aur.archlinux.org}
XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[1]}(): }'

# Author information for merge commits
export GIT_AUTHOR_NAME=aurutils
export GIT_AUTHOR_EMAIL=aurutils@localhost
export GIT_COMMITTER_NAME=aurutils
export GIT_COMMITTER_EMAIL=aurutils@localhost

# Skip global git-config
export GIT_CONFIG_GLOBAL=/dev/null
export GIT_CONFIG_NOSYSTEM=1

# default options
existing=0 recurse=0 discard=0 sync=merge

results() {
    local mode=$1 prev=$2 current=$3 path=$4 dest=$5

    if [[ -w $dest ]]; then
        printf >> "$dest" '%s:%s:%s:file://%s\n' "$mode" "$prev" "$current" "$path"
    fi
}

usage() {
    cat <<! | base64 -d
ICAgICAgICAgICAgIC4tLX5+LF9fCjotLi4uLiwtLS0tLS0tYH5+Jy5fLicKIGAtLCwsICAs
XyAgICAgIDsnflUnCiAgXywtJyAsJ2AtX187ICctLS4KIChfLyd+fiAgICAgICcnJycoOwoK
!
    printf >&2 'usage: %s [-r] [--rebase|--reset|--fetch-only] [--] pkgname...\n' "$argv0"
    exit 1
}

# option handling
source /usr/share/makepkg/util/parseopts.sh

opt_short='rS'
opt_long=('existing' 'fetch-only' 'reset' 'rebase' 'results:' 'discard'
          'ff' 'ff-only' 'no-ff' 'no-commit' 'recurse')
opt_hidden=('dump-options' 'sync:')

if ! parseopts "$opt_short" "${opt_long[@]}" "${opt_hidden[@]}" -- "$@"; then
    usage
fi
set -- "${OPTRET[@]}"

unset rebase_args merge_args results_file
while true; do
    case "$1" in
        # aur-fetch options
        --discard)
            discard=1 ;;
        --existing)
            existing=1 ;;
        --fetch-only)
            sync=fetch ;;
        --rebase)
            sync=rebase ;;
        --reset)
            sync=reset ;;
        --results)
            shift; results_file=$(realpath -- "$1") ;;
        # git options
        --ff)
            merge_args+=(-ff) ;;
        --ff-only)
            merge_args+=(--ff-only) ;;
        --no-commit)
            merge_args+=(--no-commit) ;;
        --no-ff)
            merge_args+=(--no-ff); rebase_args+=(--no-ff) ;;
        # Compatibility options
        -S)
            printf >&2 'deprecation notice: %s -S is an alias for --discard\n' "$argv0"
            discard=1; sync=merge ;;
        --sync)
            shift; sync=$1 ;;
        --recurse|-r)
            recurse=1 ;;
        --dump-options)
            printf -- '--%s\n' "${opt_long[@]}" ${AUR_DEBUG+"${opt_hidden[@]}"}
            printf -- '%s' "${opt_short}" | sed 's/.:\?/-&\n/g'
            exit ;;
        --) shift; break ;;
    esac
    shift
done

# option validation
case $sync in
    merge|rebase|reset|fetch)
        true ;;
    auto)
        printf >&2 'deprecation notice: %s --sync=auto is an alias for --discard\n' "$argv0"
        discard=1; sync=merge ;;
    *)
        printf >&2 '%s: error: invalid --sync mode\n' "$argv0"
        exit 1 ;;
esac

if (( ! $# )); then
    printf >&2 '%s: error: no arguments given\n' "$argv0"
    exit 1
fi

if [[ -v results_file ]]; then
    : >"$results_file" || exit 1 # truncate file
fi

# Default to only allowing fast-forward merges (as git-pull)
if (( ! ${#merge_args[@]} )); then
    merge_args=(--ff-only)
fi

# Placeholder for repositories without commits
git_empty_object=$(git hash-object -t tree /dev/null)

# Main loop
if (( recurse )); then
    aur depends --pkgbase "$@" # stdin handled by aur-depends
elif (( $# == 1 )) && [[ $1 == "-" || $1 == "/dev/stdin" ]]; then
    tee # noop
else
    printf '%s\n' "$@"
fi | while read -r pkg; do
    unset -f git

    # Verify if the repository is hosted on AUR (#959)
    if (( existing )) && ! git ls-remote --exit-code "$AUR_LOCATION/$pkg" >/dev/null; then
        printf >&2 '%s: warning: package %s is not in AUR, skipping\n' "$argv0" "$pkg"
        continue

    elif [[ -d $pkg/.git ]]; then
        # Avoid issues with filesystem boundaries (#274)
        git() { command git -C "$pkg" "$@"; }

        # Retrieve new upstream commits
        git fetch -v origin >&2 || exit

        # Store original HEAD for --results output
        orig_head=$(git rev-parse --verify --quiet HEAD)
        orig_head=${orig_head:-$git_empty_object}

        # Check if merge/rebase will have an effect; if so, reset the branch HEAD
        if (( discard )) && [[ $sync == @(rebase|merge) ]]; then
            git merge-base --is-ancestor 'master@{u}' HEAD || git reset --hard HEAD
        fi

        # Merge in new history
        if [[ $sync == 'rebase' ]] || { [[ $sync == 'merge' ]] && [[ $(git config --get --type bool aurutils.rebase) == 'true' ]]; }; then
            git rebase -v "${rebase_args[@]}" origin master
            dest='HEAD'

        elif [[ $sync == 'merge' ]]; then
            git merge -v "${merge_args[@]}" origin master
            dest='HEAD'

        elif [[ $sync == 'reset' ]]; then
            git reset --hard 'master@{u}'
            dest='master@{u}'

        elif [[ $sync == 'fetch' ]]; then
            # Leave branch untouched
            dest='master@{u}'
        fi >&2 || {
            printf >&2 '%s: error: failed to %s repository %s\n' "$argv0" "$sync" "$pkg"
            exit 1
        }

        if [[ -v results_file ]]; then
            head=$(git rev-parse --verify "$dest")
            results "$sync" "$orig_head" "$head" "$PWD/$pkg" "$results_file"
        fi

    # Otherwise, try to clone anew
    elif git clone "$AUR_LOCATION/$pkg" >&2; then
        if head=$(git -C "$pkg" rev-parse --verify --quiet HEAD); then
            git -C "$pkg" --no-pager log --pretty=reference -1 >&2
        fi

        if [[ -v results_file ]]; then
            results 'clone' "$git_empty_object" "${head:-$git_empty_object}" "$PWD/$pkg" "$results_file"
        fi
    else
        printf >&2 '%s: error: failed to clone repository %s\n' "$argv0" "$pkg"
        exit 1
    fi
done

# vim: set et sw=4 sts=4 ft=sh:
