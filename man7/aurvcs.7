.TH AURVCS 7 2019-10-18 AURUTILS
.SH NAME
aurvcs \- workflows for VCS packages
.
.SH DESCRIPTION
Workflows for building and managing VCS packages.
.
.SH aur\-vercmp\-devel
Takes the contents of a local repository
.RB ( "aur\-repo \-\-list" )
and matches them against a common pattern for VCS packages
.RB ( "grep \-E $AURVCS" ).
It then looks in the
.BR aur\-sync (1)
cache
.RB ( "find $AURDEST" )
for relevant directories.
.PP
Any existing
.BR PKGBUILD (5)
files in these directories are executed, with upstream sources updated
to their latest revision.
.RB ( aur\-srcver
using
.BR "makepkg \-o" ).
.PP
Any option arguments are forwarded to
.BR aur\-repo (1).
.
.SS Program source
.EX
    #!/bin/bash
    set -e
    XDG_CACHE_HOME=${XDG_CACHE_HOME:\-$HOME/.cache}
    AURDEST=${AURDEST:\-$XDG_CACHE_HOME/aurutils/sync}
    AURVCS=${AURVCS:\-.*\-(cvs|svn|git|hg|bzr|darcs)$}

    filter_vcs() {
        awk \-v "mask=$AURVCS" \(aq$1 \(ti mask {print $1}\(aq "$@"
    }

    # Note that valid PKGBUILDs cannot contain \en in pkgname.
    get_latest_revision() {
        grep \-Fxf \- <(printf \(aq%s\en\(aq *) | xargs \-r aur srcver
    }

    # Scratch space for intermediary results.
    tmp=$(mktemp \-d)
    trap \(aqrm \-rf "$tmp"\(aq EXIT

    # Retrieve a list of the local repository contents. The repository
    # can be specified with the usual aur\-repo arguments.
    aur repo \-\-list "$@" | tee "$tmp"/db | filter_vcs - >"$tmp"/vcs

    # Pull any new AUR revisions (e.g. dependency updates) for VCS packages 
    # and inspect them with aur-view(1). This is done before running aur\-srcver,
    # which runs makepkg and sources the PKGBUILD.
    cd "$AURDEST"
    aur fetch \- <"$tmp"/vcs
    aur view \-a "$tmp"/vcs

    # Find VCS packages that are outdated according to aur\-srcver.
    # This checks out the latest revision for existing source directories,
    # assuming the PKGBUILD has been viewed priorly.
    aur vercmp \-p <(get_latest_revision <"$tmp"/vcs) <"$tmp"/db
.EE
.
.SS Notes
In the last line, the resulting package versions
.RB ( "get_latest_revision" )
are compared against the local repository
.RB ( "aur repo \-\-list" ).
If the package version is newer, it is printed to stdout. The packages
can then be built with
.BR aur\-build (1)
as follows:
.PP
.EX
    $ cd "$AURDEST"
    $ aur build \-a <(aur vercmp\-devel | cut \-d" " \-f1)
.EE
.PP
Version-control packages typically have
.B pkgver
set to the upstream revision at the time of package submission, making
the AUR-advertised version older than the latest version.
.
.SS Populating the cache
As described, the above relies on already available
.BR PKGBUILD (5)
files. If the
.BR aur\-sync (1)
cache is sparse or the package has meanwhile been updated by the AUR
maintainer (for example, to indicate a new upstream source),
information reported by
.B aur\-vercmp\-devel
may be incomplete.
.PP
The following mediates this by downloading all VCS packages in a local
repository anew, with all build files and their diffs offered for
inspection.
.PP
.EX
    $ mapfile \-t packages < <(aur repo \-\-list | cut \-f1 | grep \-E "$AURVCS")
    $ aur sync "${packages[@]}" \-\-no\-ver \-\-no\-build
.EE
.
\" The last pipeline will also show any non-VCS dependencies.  Since
\" the respective PKGBUILDs are not run by aur\-srcver, they are not of
\" relevance. Use aur\-fetch manually?
.
.SH AUTHORS
.MT https://github.com/AladW
Alad Wenter
.ME
.
.\" vim: set textwidth=72:
