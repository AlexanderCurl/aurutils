#!/bin/bash
[[ -v AUR_DEBUG ]] && set -o xtrace
set -o errexit
shopt -s nullglob
argv0=chroot-batch
startdir=$PWD
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default options
overwrite=0 build_user=$SUDO_USER

# option parsing
source /usr/share/makepkg/util/parseopts.sh
source /usr/share/makepkg/util.sh

orig_argv=("$@")
opt_short='c:U:f'
opt_long=('config:' 'user:' 'overwrite')

if ! parseopts "$opt_short" "${opt_long[@]}" -- "$@"; then
    exit 1
fi
set -- "${OPTRET[@]}"

unset build_args chroot_args
while true; do
    case $1 in
        -f|--overwrite)
            overwrite=1 ;;
        -c|--config)
            shift; build_args+=(--pacman-conf "$1")
            chroot_args+=(--pacman-conf "$1") ;;
        -U|--user)
            shift; build_user=$1 ;;
        --) shift; break ;;
    esac
    shift
done

# XXX: assumption on --arg-file: pkgbase == dirname (--dry-run output is separated
# by colons, with the package path at the end of each line).
argfile=$1 db_name=$2 db_root=$3

[[ ! $argfile ]] && { printf >&2 '%s: $1 <argfile> required\n' "$argv0"; exit 1; }
[[ ! $db_name ]] && { printf >&2 '%s: $2 <repo> required\n' "$argv0"; exit 1; }
[[ ! $db_root ]] && { printf >&2 '%s: $3 <root> required\n' "$argv0"; exit 1; }

# resolve symlinks
db_path=$(realpath -e -- "$db_root/$db_name".db)
files_path=$(realpath -e -- "$db_root/$db_name".files)

# sanity checks done, re-exec as root
if (( EUID != 0 )); then
    exec sudo --preserve-env=GNUPGHOME,SSH_AUTH_SOCK,AUR_DEBUG "${BASH_SOURCE[0]}" "${orig_argv[@]}"
fi

# run user/unpriviliged commands with setpriv(1)
runas() { 
    setpriv --reuid "$1" --regid "$1" --init-groups --reset-env -- "${@:2}"
}

# PKGEXT in container may differ from host
chroot_makepkg_conf=$(aur chroot --path)/etc/makepkg.conf
build_args+=(--makepkg-conf "$chroot_makepkg_conf")

# 1. check which packages in the queue need to be built
mapfile -t build_dry_run < <(
    runas "$build_user" aur build -a "$argfile" -d "$db_name" --root "$db_root" \
          "${build_args[@]}" --dry-run --pkgver 2>/dev/null
)
wait "$!"

if (( overwrite == 0 )); then
    printf '%s\n' "${build_dry_run[@]}" | awk '/^exist:/ {print}'

    mapfile -t pkgbase_targets < <(
        printf '%s\n' "${build_dry_run[@]}" | awk -F: '/^build:/ {print $2}')
else
    mapfile -t pkgbase_targets < <(
        printf '%s\n' "${build_dry_run[@]}" | awk -F: '{print $2}')
fi

# 2. chroot preparation
aur chroot --create --update "${chroot_args[@]}"

batch_sign() {
    local user=$1 passphrase=$2
    shift 2

    local gpg_args=(--detach-sign --no-armor --batch --verbose
                    --pinentry-mode loopback --passphrase-fd 0)
    [[ -v GNUPGHOME ]] && gpg_args+=(--homedir "$GNUPGHOME")

    printf '%s' "$passphrase" | runas "$user" gpg "${gpg_args[@]}" "$@"
    return "${PIPESTATUS[1]}"
}

repo_add_and_sign() {
    # Ensure the passphrase is not stored as an environment variable by saving
    # it in a local variable inside a function.  Note that when the passphrase
    # is cached in gpg-agent (with duration set by default-cache-ttl), it will
    # be used regardless of input read here.
    local passphrase pkglist pkgbase
    read -s -p 'GPG passphrase for signing packages: ' passphrase
    echo

    #global var_tmp build_user db_path
    for pkgbase in "$@"; do
        cd -- "$startdir/$pkgbase"
        PKGDEST="$var_tmp" aur chroot --build "${chroot_args[@]}" \
               --cargs -c,-u,-U,"$build_user"

        cd -- "$var_tmp"
        pkglist=(*) siglist=()

        for pkg in "${pkglist[@]}"; do
            batch_sign "$build_user" "$passphrase" --output "$pkg".sig "$pkg"
            siglist+=("$pkg".sig)
        done

        # Move to local repository and update database
        mv -f "${pkglist[@]}" "${siglist[@]}" "$db_root"
        runas "$build_user" env -C "$db_root" LANG=C repo-add "$db_path" "${pkglist[@]}"

        # Sign database in temporary directory (var_tmp)
        for f in "$db_path" "$files_path"; do
            batch_sign "$build_user" "$passphrase" --output "$var_tmp/${f##*/}".sig "$f"
        done

        # Move signatures and create symlinks
        mv -v "${db_path##*/}".sig "${files_path##*/}".sig "$db_root"
        cd -- "$db_root"

        cp -sf "$db_path".sig "$db_root/$db_name".db.sig 
        cp -sf "$files_path".sig "$db_root/$db_name".files.sig
    done
}

# 3. main loop
if (( ${#pkgbase_targets[@]} )); then
    var_tmp=$(runas "$build_user" mktemp -d --tmpdir=/var/tmp/ "$argv0.XXXXXXXX")
    trap 'rm -df -- "$var_tmp"' EXIT

    repo_add_and_sign "${pkgbase_targets[@]}"
else
    printf >&2 '%s: there is nothing to do\n' "$argv0"
    exit 1
fi
